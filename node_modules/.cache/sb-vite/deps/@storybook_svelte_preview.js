import {
  decorateStory,
  render,
  renderToCanvas
} from "./chunk-X33TSI3C.js";
import "./chunk-X7HCJ7ZS.js";
import "./chunk-CTY5WESM.js";
import "./chunk-RJ43DBYY.js";
import "./chunk-TTOOQL5P.js";
import {
  SNIPPET_RENDERED,
  SourceType,
  enhanceArgTypes
} from "./chunk-PJIJHUUB.js";
import "./chunk-TYH7BE35.js";
import "./chunk-4H7SMCZ4.js";
import "./chunk-D5MVGFCZ.js";
import "./chunk-BLUS75FO.js";
import "./chunk-MAF6KXPT.js";
import "./chunk-UNCWL76U.js";
import "./chunk-AGKZFVK2.js";
import "./chunk-EOMQLOPG.js";
import "./chunk-E2K76V5W.js";
import "./chunk-FNVNWGFY.js";
import "./chunk-N3UW2J7F.js";
import "./chunk-Y62BMSOZ.js";
import "./chunk-5WR3WYSL.js";
import "./chunk-IWK4B5GE.js";
import "./chunk-4AOKGF3U.js";
import "./chunk-AJUJKM3E.js";
import "./chunk-FZOK36NQ.js";
import "./chunk-GLY76XHD.js";
import "./chunk-5ME5KE2Q.js";
import "./chunk-EDYCBJQK.js";
import "./chunk-FFUYVG4O.js";
import "./chunk-LPC22XQV.js";
import "./chunk-7CHRVKKT.js";
import "./chunk-AJ5BABJY.js";
import "./chunk-J6CEENEN.js";
import "./chunk-WE5ELTTT.js";
import {
  require_client_logger
} from "./chunk-KUWY3STC.js";
import {
  require_preview_api
} from "./chunk-Y33QRGX4.js";
import {
  __toESM
} from "./chunk-BKDDKEDW.js";

// node_modules/@storybook/svelte/dist/config.mjs
var import_client_logger = __toESM(require_client_logger(), 1);
var import_preview_api = __toESM(require_preview_api(), 1);
function hasKeyword(keyword, keywords) {
  return keywords ? keywords.find((k) => k.name === keyword) != null : false;
}
var extractArgTypes = (component) => {
  try {
    let docgen = component.__docgen;
    if (docgen)
      return createArgTypes(docgen);
  } catch (err) {
    import_client_logger.logger.log(`Error extracting argTypes: ${err}`);
  }
  return {};
};
var createArgTypes = (docgen) => {
  let results = {};
  return docgen.data && docgen.data.forEach((item) => {
    var _a, _b;
    results[item.name] = { control: parseTypeToControl(item.type), name: item.name, description: item.description || void 0, type: { required: hasKeyword("required", item.keywords || []), name: (_a = item.type) == null ? void 0 : _a.text }, table: { type: { summary: (_b = item.type) == null ? void 0 : _b.text }, defaultValue: { summary: item.defaultValue }, category: "properties" } };
  }), docgen.events && docgen.events.forEach((item) => {
    results[`event_${item.name}`] = { name: item.name, action: item.name, control: false, ...item.description ? { description: item.description } : {}, table: { category: "events" } };
  }), docgen.slots && docgen.slots.forEach((item) => {
    var _a;
    results[`slot_${item.name}`] = { name: item.name, control: false, description: [item.description, (_a = item.params) == null ? void 0 : _a.map((p) => `\`${p.name}\``).join(" ")].filter((p) => p).join(`

`), table: { category: "slots" } };
  }), results;
};
var parseTypeToControl = (type) => {
  if (!type)
    return null;
  if (type.kind === "type")
    switch (type.type) {
      case "string":
        return { type: "text" };
      case "enum":
        return { type: "radio" };
      case "any":
        return { type: "object" };
      default:
        return { type: type.type };
    }
  else if (type.kind === "union" && Array.isArray(type.type) && !type.type.find((t) => t.type !== "string"))
    return { type: "radio", options: type.type.filter((t) => t.kind === "const").map((t) => t.value) };
  return null;
};
function extractComponentDescription(component) {
  if (!component)
    return "";
  let { __docgen = {} } = component;
  return __docgen.description;
}
var skipSourceRender = (context) => {
  var _a;
  let sourceParams = (_a = context == null ? void 0 : context.parameters.docs) == null ? void 0 : _a.source, isArgsStory = context == null ? void 0 : context.parameters.__isArgsStory;
  return (sourceParams == null ? void 0 : sourceParams.type) === SourceType.DYNAMIC ? false : !isArgsStory || (sourceParams == null ? void 0 : sourceParams.code) || (sourceParams == null ? void 0 : sourceParams.type) === SourceType.CODE;
};
function toSvelteProperty(key, value, argTypes) {
  return value == null || argTypes[key] && argTypes[key].defaultValue === value ? null : value === true ? key : typeof value == "string" ? `${key}=${JSON.stringify(value)}` : `${key}={${JSON.stringify(value)}}`;
}
function getComponentName(component) {
  if (component == null)
    return null;
  let { __docgen = {} } = component, { name } = __docgen;
  return name ? (name.endsWith(".svelte") && (name = name.substring(0, name.length - 7)), name) : component.name;
}
function generateSvelteSource(component, args, argTypes, slotProperty) {
  let name = getComponentName(component);
  if (!name)
    return null;
  let props = Object.entries(args).filter(([k]) => k !== slotProperty).map(([k, v]) => toSvelteProperty(k, v, argTypes)).filter((p) => p).join(" "), slotValue = slotProperty ? args[slotProperty] : null;
  return slotValue ? `<${name} ${props}>
    ${slotValue}
</${name}>` : `<${name} ${props}/>`;
}
function getWrapperProperties(component) {
  var _a;
  let { __docgen } = component;
  return __docgen ? __docgen.keywords.find((kw) => kw.name === "wrapper") ? { wrapper: true, slotProperty: (_a = __docgen.data.find((prop) => prop.keywords.find((kw) => kw.name === "slot"))) == null ? void 0 : _a.name } : { wrapper: false } : { wrapper: false };
}
var sourceDecorator = (storyFn, context) => {
  let channel = import_preview_api.addons.getChannel(), skip = skipSourceRender(context), story = storyFn(), source;
  if ((0, import_preview_api.useEffect)(() => {
    if (!skip && source) {
      let { id, unmappedArgs } = context;
      channel.emit(SNIPPET_RENDERED, { id, args: unmappedArgs, source });
    }
  }), skip)
    return story;
  let { parameters: parameters3 = {}, args = {}, component: ctxtComponent } = context || {}, { Component: component = {} } = story, { wrapper, slotProperty } = getWrapperProperties(component);
  wrapper && (parameters3.component && (0, import_client_logger.deprecate)("parameters.component is deprecated. Using context.component instead."), component = ctxtComponent);
  let generated = generateSvelteSource(component, args, context == null ? void 0 : context.argTypes, slotProperty);
  return generated && (source = generated), story;
};
var parameters = { docs: { story: { inline: true }, extractArgTypes, extractComponentDescription } };
var decorators = [sourceDecorator];
var argTypesEnhancers = [enhanceArgTypes];
var parameters2 = { renderer: "svelte", ...parameters };
export {
  decorateStory as applyDecorators,
  argTypesEnhancers,
  decorators,
  parameters2 as parameters,
  render,
  renderToCanvas
};
//# sourceMappingURL=@storybook_svelte_preview.js.map
