import {
  SvelteComponentDev,
  assign,
  binding_callbacks,
  check_outros,
  construct_svelte_component_dev,
  create_component,
  destroy_component,
  detach_dev,
  dispatch_dev,
  empty,
  get_spread_object,
  get_spread_update,
  globals,
  group_outros,
  init,
  insert_dev,
  mount_component,
  onMount,
  safe_not_equal,
  transition_in,
  transition_out,
  validate_slots
} from "./chunk-RJ43DBYY.js";
import {
  require_core_events
} from "./chunk-AJ5BABJY.js";
import {
  dedent
} from "./chunk-J6CEENEN.js";
import {
  require_preview_api
} from "./chunk-Y33QRGX4.js";
import {
  __toESM
} from "./chunk-BKDDKEDW.js";

// node_modules/@storybook/svelte/dist/chunk-KSAWIQN3.mjs
var import_preview_api = __toESM(require_preview_api(), 1);

// node_modules/@storybook/svelte/templates/SlotDecorator.svelte
var { Object: Object_1 } = globals;
function create_else_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*props*/
    ctx[2]
  ];
  var switch_value = (
    /*Component*/
    ctx[1]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty & /*props*/
    4) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*props*/
        ctx2[2]
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[8](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*Component*/
      2 && switch_value !== (switch_value = /*Component*/
      ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          ctx2[8](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*props*/
        4 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*props*/
          ctx2[2]
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      ctx[8](null);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_else_block.name,
    type: "else",
    source: "(29:0) {:else}",
    ctx
  });
  return block;
}
function create_if_block(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*decorator*/
    ctx[0].props
  ];
  var switch_value = (
    /*decorator*/
    ctx[0].Component
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx: ctx2 }
    };
    if (dirty !== void 0 && dirty & /*decorator*/
    1) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*decorator*/
        ctx2[0].props
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[7](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*decorator*/
      1 && switch_value !== (switch_value = /*decorator*/
      ctx2[0].Component)) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          ctx2[7](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*decorator*/
        1 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*decorator*/
          ctx2[0].props
        )]) : {};
        if (dirty & /*$$scope, Component, props, instance*/
        1038) {
          switch_instance_changes.$$scope = { dirty, ctx: ctx2 };
        }
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      ctx[7](null);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_if_block.name,
    type: "if",
    source: "(25:0) {#if decorator}",
    ctx
  });
  return block;
}
function create_default_slot(ctx) {
  let switch_instance;
  let switch_instance_anchor;
  let current;
  const switch_instance_spread_levels = [
    /*props*/
    ctx[2]
  ];
  var switch_value = (
    /*Component*/
    ctx[1]
  );
  function switch_props(ctx2, dirty) {
    let switch_instance_props = {};
    if (dirty !== void 0 && dirty & /*props*/
    4) {
      switch_instance_props = get_spread_update(switch_instance_spread_levels, [get_spread_object(
        /*props*/
        ctx2[2]
      )]);
    } else {
      for (let i = 0; i < switch_instance_spread_levels.length; i += 1) {
        switch_instance_props = assign(switch_instance_props, switch_instance_spread_levels[i]);
      }
    }
    return {
      props: switch_instance_props,
      $$inline: true
    };
  }
  if (switch_value) {
    switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx));
    ctx[6](switch_instance);
  }
  const block = {
    c: function create() {
      if (switch_instance)
        create_component(switch_instance.$$.fragment);
      switch_instance_anchor = empty();
    },
    m: function mount(target, anchor) {
      if (switch_instance)
        mount_component(switch_instance, target, anchor);
      insert_dev(target, switch_instance_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, dirty) {
      if (dirty & /*Component*/
      2 && switch_value !== (switch_value = /*Component*/
      ctx2[1])) {
        if (switch_instance) {
          group_outros();
          const old_component = switch_instance;
          transition_out(old_component.$$.fragment, 1, 0, () => {
            destroy_component(old_component, 1);
          });
          check_outros();
        }
        if (switch_value) {
          switch_instance = construct_svelte_component_dev(switch_value, switch_props(ctx2, dirty));
          ctx2[6](switch_instance);
          create_component(switch_instance.$$.fragment);
          transition_in(switch_instance.$$.fragment, 1);
          mount_component(switch_instance, switch_instance_anchor.parentNode, switch_instance_anchor);
        } else {
          switch_instance = null;
        }
      } else if (switch_value) {
        const switch_instance_changes = dirty & /*props*/
        4 ? get_spread_update(switch_instance_spread_levels, [get_spread_object(
          /*props*/
          ctx2[2]
        )]) : {};
        switch_instance.$set(switch_instance_changes);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      if (switch_instance)
        transition_in(switch_instance.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      if (switch_instance)
        transition_out(switch_instance.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(switch_instance_anchor);
      }
      ctx[6](null);
      if (switch_instance)
        destroy_component(switch_instance, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_default_slot.name,
    type: "slot",
    source: "(26:2) <svelte:component this={decorator.Component} {...decorator.props} bind:this={decoratorInstance}>",
    ctx
  });
  return block;
}
function create_fragment(ctx) {
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  const if_block_creators = [create_if_block, create_else_block];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*decorator*/
      ctx2[0]
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  const block = {
    c: function create() {
      if_block.c();
      if_block_anchor = empty();
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      if_blocks[current_block_type_index].m(target, anchor);
      insert_dev(target, if_block_anchor, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(if_block_anchor.parentNode, if_block_anchor);
      }
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o: function outro(local) {
      transition_out(if_block);
      current = false;
    },
    d: function destroy(detaching) {
      if (detaching) {
        detach_dev(if_block_anchor);
      }
      if_blocks[current_block_type_index].d(detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance_1($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("SlotDecorator", slots, []);
  let { decorator = void 0 } = $$props;
  let { Component } = $$props;
  let { props = {} } = $$props;
  let { on = void 0 } = $$props;
  let instance2;
  let decoratorInstance;
  function getInstance() {
    return instance2 || decoratorInstance;
  }
  if (on) {
    Object.keys(on).forEach((eventName) => {
      onMount(() => getInstance().$on(eventName, on[eventName]));
    });
  }
  $$self.$$.on_mount.push(function() {
    if (Component === void 0 && !("Component" in $$props || $$self.$$.bound[$$self.$$.props["Component"]])) {
      console.warn("<SlotDecorator> was created without expected prop 'Component'");
    }
  });
  const writable_props = ["decorator", "Component", "props", "on"];
  Object_1.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<SlotDecorator> was created with unknown prop '${key}'`);
  });
  function switch_instance_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      instance2 = $$value;
      $$invalidate(3, instance2);
    });
  }
  function switch_instance_binding_1($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      decoratorInstance = $$value;
      $$invalidate(4, decoratorInstance);
    });
  }
  function switch_instance_binding_2($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      instance2 = $$value;
      $$invalidate(3, instance2);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("decorator" in $$props2)
      $$invalidate(0, decorator = $$props2.decorator);
    if ("Component" in $$props2)
      $$invalidate(1, Component = $$props2.Component);
    if ("props" in $$props2)
      $$invalidate(2, props = $$props2.props);
    if ("on" in $$props2)
      $$invalidate(5, on = $$props2.on);
  };
  $$self.$capture_state = () => ({
    onMount,
    decorator,
    Component,
    props,
    on,
    instance: instance2,
    decoratorInstance,
    getInstance
  });
  $$self.$inject_state = ($$props2) => {
    if ("decorator" in $$props2)
      $$invalidate(0, decorator = $$props2.decorator);
    if ("Component" in $$props2)
      $$invalidate(1, Component = $$props2.Component);
    if ("props" in $$props2)
      $$invalidate(2, props = $$props2.props);
    if ("on" in $$props2)
      $$invalidate(5, on = $$props2.on);
    if ("instance" in $$props2)
      $$invalidate(3, instance2 = $$props2.instance);
    if ("decoratorInstance" in $$props2)
      $$invalidate(4, decoratorInstance = $$props2.decoratorInstance);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  return [
    decorator,
    Component,
    props,
    instance2,
    decoratorInstance,
    on,
    switch_instance_binding,
    switch_instance_binding_1,
    switch_instance_binding_2
  ];
}
var SlotDecorator = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance_1, create_fragment, safe_not_equal, {
      decorator: 0,
      Component: 1,
      props: 2,
      on: 5
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "SlotDecorator",
      options,
      id: create_fragment.name
    });
  }
  get decorator() {
    throw new Error("<SlotDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set decorator(value) {
    throw new Error("<SlotDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get Component() {
    throw new Error("<SlotDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set Component(value) {
    throw new Error("<SlotDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get props() {
    throw new Error("<SlotDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set props(value) {
    throw new Error("<SlotDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get on() {
    throw new Error("<SlotDecorator>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set on(value) {
    throw new Error("<SlotDecorator>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var SlotDecorator_default = SlotDecorator;

// node_modules/@storybook/svelte/dist/chunk-KSAWIQN3.mjs
var import_core_events = __toESM(require_core_events(), 1);

// node_modules/@storybook/svelte/templates/PreviewRender.svelte
var { Object: Object_12 } = globals;
function create_fragment2(ctx) {
  let slotdecorator;
  let current;
  slotdecorator = new SlotDecorator_default({
    props: {
      Component: (
        /*Component*/
        ctx[0]
      ),
      props: (
        /*props*/
        ctx[1]
      ),
      on: {
        .../*eventsFromArgTypes*/
        ctx[3],
        .../*on*/
        ctx[2]
      }
    },
    $$inline: true
  });
  const block = {
    c: function create() {
      create_component(slotdecorator.$$.fragment);
    },
    l: function claim(nodes) {
      throw new Error("options.hydrate only works if the component was compiled with the `hydratable: true` option");
    },
    m: function mount(target, anchor) {
      mount_component(slotdecorator, target, anchor);
      current = true;
    },
    p: function update(ctx2, [dirty]) {
      const slotdecorator_changes = {};
      if (dirty & /*Component*/
      1)
        slotdecorator_changes.Component = /*Component*/
        ctx2[0];
      if (dirty & /*props*/
      2)
        slotdecorator_changes.props = /*props*/
        ctx2[1];
      if (dirty & /*on*/
      4)
        slotdecorator_changes.on = {
          .../*eventsFromArgTypes*/
          ctx2[3],
          .../*on*/
          ctx2[2]
        };
      slotdecorator.$set(slotdecorator_changes);
    },
    i: function intro(local) {
      if (current)
        return;
      transition_in(slotdecorator.$$.fragment, local);
      current = true;
    },
    o: function outro(local) {
      transition_out(slotdecorator.$$.fragment, local);
      current = false;
    },
    d: function destroy(detaching) {
      destroy_component(slotdecorator, detaching);
    }
  };
  dispatch_dev("SvelteRegisterBlock", {
    block,
    id: create_fragment2.name,
    type: "component",
    source: "",
    ctx
  });
  return block;
}
function instance($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  validate_slots("PreviewRender", slots, []);
  let { name } = $$props;
  let { kind } = $$props;
  let { storyFn } = $$props;
  let { showError } = $$props;
  let { storyContext } = $$props;
  let {
    /** @type {SvelteComponent} */
    Component,
    /** @type {any} */
    props = {},
    /** @type {{[string]: () => {}}} Attach svelte event handlers */
    on
  } = storyFn();
  const eventsFromArgTypes = Object.fromEntries(Object.entries(storyContext.argTypes).filter(([k, v]) => v.action && props[k] != null).map(([k, v]) => [v.action, props[k]]));
  if (!Component) {
    showError({
      title: `Expecting a Svelte component from the story: "${name}" of "${kind}".`,
      description: dedent`
        Did you forget to return the Svelte component configuration from the story?
        Use "() => ({ Component: YourComponent, props: {} })"
        when defining the story.
      `
    });
  }
  $$self.$$.on_mount.push(function() {
    if (name === void 0 && !("name" in $$props || $$self.$$.bound[$$self.$$.props["name"]])) {
      console.warn("<PreviewRender> was created without expected prop 'name'");
    }
    if (kind === void 0 && !("kind" in $$props || $$self.$$.bound[$$self.$$.props["kind"]])) {
      console.warn("<PreviewRender> was created without expected prop 'kind'");
    }
    if (storyFn === void 0 && !("storyFn" in $$props || $$self.$$.bound[$$self.$$.props["storyFn"]])) {
      console.warn("<PreviewRender> was created without expected prop 'storyFn'");
    }
    if (showError === void 0 && !("showError" in $$props || $$self.$$.bound[$$self.$$.props["showError"]])) {
      console.warn("<PreviewRender> was created without expected prop 'showError'");
    }
    if (storyContext === void 0 && !("storyContext" in $$props || $$self.$$.bound[$$self.$$.props["storyContext"]])) {
      console.warn("<PreviewRender> was created without expected prop 'storyContext'");
    }
  });
  const writable_props = ["name", "kind", "storyFn", "showError", "storyContext"];
  Object_12.keys($$props).forEach((key) => {
    if (!~writable_props.indexOf(key) && key.slice(0, 2) !== "$$" && key !== "slot")
      console.warn(`<PreviewRender> was created with unknown prop '${key}'`);
  });
  $$self.$$set = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(4, name = $$props2.name);
    if ("kind" in $$props2)
      $$invalidate(5, kind = $$props2.kind);
    if ("storyFn" in $$props2)
      $$invalidate(6, storyFn = $$props2.storyFn);
    if ("showError" in $$props2)
      $$invalidate(7, showError = $$props2.showError);
    if ("storyContext" in $$props2)
      $$invalidate(8, storyContext = $$props2.storyContext);
  };
  $$self.$capture_state = () => ({
    SlotDecorator: SlotDecorator_default,
    dedent,
    name,
    kind,
    storyFn,
    showError,
    storyContext,
    Component,
    props,
    on,
    eventsFromArgTypes
  });
  $$self.$inject_state = ($$props2) => {
    if ("name" in $$props2)
      $$invalidate(4, name = $$props2.name);
    if ("kind" in $$props2)
      $$invalidate(5, kind = $$props2.kind);
    if ("storyFn" in $$props2)
      $$invalidate(6, storyFn = $$props2.storyFn);
    if ("showError" in $$props2)
      $$invalidate(7, showError = $$props2.showError);
    if ("storyContext" in $$props2)
      $$invalidate(8, storyContext = $$props2.storyContext);
    if ("Component" in $$props2)
      $$invalidate(0, Component = $$props2.Component);
    if ("props" in $$props2)
      $$invalidate(1, props = $$props2.props);
    if ("on" in $$props2)
      $$invalidate(2, on = $$props2.on);
  };
  if ($$props && "$$inject" in $$props) {
    $$self.$inject_state($$props.$$inject);
  }
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*storyFn*/
    64) {
      $:
        $$invalidate(0, { Component, props = {}, on } = storyFn(), Component, ($$invalidate(1, props), $$invalidate(6, storyFn)), ($$invalidate(2, on), $$invalidate(6, storyFn)));
    }
  };
  return [
    Component,
    props,
    on,
    eventsFromArgTypes,
    name,
    kind,
    storyFn,
    showError,
    storyContext
  ];
}
var PreviewRender = class extends SvelteComponentDev {
  constructor(options) {
    super(options);
    init(this, options, instance, create_fragment2, safe_not_equal, {
      name: 4,
      kind: 5,
      storyFn: 6,
      showError: 7,
      storyContext: 8
    });
    dispatch_dev("SvelteRegisterComponent", {
      component: this,
      tagName: "PreviewRender",
      options,
      id: create_fragment2.name
    });
  }
  get name() {
    throw new Error("<PreviewRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set name(value) {
    throw new Error("<PreviewRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get kind() {
    throw new Error("<PreviewRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set kind(value) {
    throw new Error("<PreviewRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get storyFn() {
    throw new Error("<PreviewRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set storyFn(value) {
    throw new Error("<PreviewRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get showError() {
    throw new Error("<PreviewRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set showError(value) {
    throw new Error("<PreviewRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  get storyContext() {
    throw new Error("<PreviewRender>: Props cannot be read directly from the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
  set storyContext(value) {
    throw new Error("<PreviewRender>: Props cannot be set directly on the component instance unless compiling with 'accessors: true' or '<svelte:options accessors/>'");
  }
};
var PreviewRender_default = PreviewRender;

// node_modules/@storybook/svelte/dist/chunk-KSAWIQN3.mjs
function unWrap(obj) {
  return obj && typeof obj == "object" && "default" in obj ? obj.default : obj;
}
function prepareStory(context, rawStory, rawInnerStory) {
  let story = unWrap(rawStory), innerStory = rawInnerStory && unWrap(rawInnerStory), preparedStory;
  return !story || Object.keys(story).length === 0 ? preparedStory = { Component: context.component } : story.Component ? preparedStory = story : preparedStory = { Component: story }, innerStory ? { Component: SlotDecorator_default, props: { ...innerStory, decorator: preparedStory } } : preparedStory;
}
function decorateStory(storyFn, decorators) {
  return decorators.reduce((decorated, decorator) => (context) => {
    let story, decoratedStory = decorator((update) => (story = decorated({ ...context, ...(0, import_preview_api.sanitizeStoryContextUpdate)(update) }), story), context);
    return story || (story = decorated(context)), decoratedStory === story ? story : prepareStory(context, decoratedStory, story);
  }, (context) => prepareStory(context, storyFn(context)));
}
var componentsByDomElement = /* @__PURE__ */ new Map();
function teardown(canvasElement) {
  componentsByDomElement.has(canvasElement) && (componentsByDomElement.get(canvasElement).$destroy(), canvasElement.innerHTML = "", componentsByDomElement.delete(canvasElement));
}
var storyIdsToRemountFromResetArgsEvent = /* @__PURE__ */ new Set();
import_preview_api.addons.getChannel().on(import_core_events.RESET_STORY_ARGS, ({ storyId }) => {
  storyIdsToRemountFromResetArgsEvent.add(storyId);
});
function renderToCanvas({ storyFn, kind, name, showMain, showError, storyContext, forceRemount }, canvasElement) {
  let existingComponent = componentsByDomElement.get(canvasElement), remount = forceRemount;
  if (storyIdsToRemountFromResetArgsEvent.has(storyContext.id) && (remount = true, storyIdsToRemountFromResetArgsEvent.delete(storyContext.id)), remount && teardown(canvasElement), !existingComponent || remount) {
    let createdComponent = new PreviewRender_default({ target: canvasElement, props: { storyFn, storyContext, name, kind, showError } });
    componentsByDomElement.set(canvasElement, createdComponent);
  } else
    existingComponent.$set({ storyFn, storyContext, name, kind, showError });
  return showMain(), () => {
    teardown(canvasElement);
  };
}
var render = (args, context) => {
  let { id, component: Component } = context;
  if (!Component)
    throw new Error(`Unable to render story ${id} as the component annotation is missing from the default export`);
  return { Component, props: args };
};

export {
  decorateStory,
  renderToCanvas,
  render
};
//# sourceMappingURL=chunk-X33TSI3C.js.map
